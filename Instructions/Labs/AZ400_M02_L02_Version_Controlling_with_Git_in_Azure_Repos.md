---
lab:
  title: Azure Repos에서 Git을 사용하여 버전 제어
  module: 'Module 02: Work with Azure Repos and GitHub'
---

# Azure Repos에서 Git을 사용하여 버전 제어

## 학생용 랩 매뉴얼

## 랩 요구 사항

- 이 랩은 **Microsoft Edge** 또는 [Azure DevOps 지원 브라우저](https://docs.microsoft.com/azure/devops/server/compatibility)가 필요합니다.

- **Azure DevOps 조직 설정:** 이 랩에 사용할 수 있는 Azure DevOps 조직이 아직 없으면 [조직 또는 프로젝트 컬렉션 만들기](https://docs.microsoft.com/azure/devops/organizations/accounts/create-organization)에서 제공되는 지침에 따라 조직을 만듭니다.

- Git 2.29.2 이상이 아직 설치되어 있지 않은 경우 웹 브라우저를 시작하고 Windows용 Git 다운로드 페이지[로 이동하여 ](https://gitforwindows.org/)다운로드하고 설치합니다.
- Visual Studio Code가 아직 설치되어 있지 않은 경우 웹 브라우저 창에서 Visual Studio Code 다운로드 페이지[로 이동하여 ](https://code.visualstudio.com/)다운로드하고 설치합니다.
- Visual Studio C# 확장이 아직 설치되어 있지 않은 경우 웹 브라우저 창에서 C# 확장 설치 페이지[로 이동하여 ](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)설치합니다.

## 랩 개요

Azure DevOps에서는 두 가지 유형의 버전 제어가 지원됩니다. 그 중 하나는 Git를 사용한 제어이고 다른 하나는 TFVC(Team Foundation 버전 제어)를 통한 제어입니다. 이 두 가지 버전 제어 시스템의 기능을 요약하여 설명하자면 다음과 같습니다.

- **TFVC(Team Foundation 버전 제어):** TFVC는 중앙 집중식 버전 제어 시스템입니다. 일반적으로 팀 멤버는 자신의 고유 개발 컴퓨터에 각 파일 버전 하나만 보유합니다. 기록 데이터는 서버에만 보관됩니다. 분기는 경로에 기반을 두며 서버에서 만들어집니다.

- **Git:** Git은 분산 버전 제어 시스템입니다. 개발자 머신 등의 로컬 환경에 Git 리포지토리를 저장할 수 있습니다. 각 개발자는 자신의 개발 컴퓨터에 소스 리포지토리의 복사본을 가지고 있습니다. 개발자는 개발 머신에서 각 변경 내용을 커밋하고 기록과 같은 버전 제어 작업을 수행하고 네트워크 연결 없이 비교할 수 있습니다.

신규 프로젝트의 기본 버전 제어 공급자는 Git입니다. TFVC의 중앙 집중식 버전 제어 기능이 필요한 경우가 아니면 프로젝트 버전 제어에 Git을 사용해야 합니다.

이 랩에서는 Azure DevOps의 중앙 집중식 Git 리포지토리와 쉽게 동기화할 수 있는 로컬 Git 리포지토리를 설정하는 방법을 배웁니다. 또한 Git 분기 지정 및 병합 지원에 대해서도 알아봅니다. 여기서는 Visual Studio Code를 사용하지만 어떤 Git 호환 클라이언트를 사용하든 프로세스는 동일합니다.

## 목표

이 랩을 완료하면 다음 작업을 수행할 수 있습니다.

- 기존 리포지토리를 복제합니다.
- 커밋으로 작업을 저장합니다.
- 변경 기록을 검토합니다.
- Visual Studio Code를 통해 분기를 사용합니다.

## 예상 소요 시간: 60분

## Instructions

### 연습 0: 랩 필수 구성 요소 구성

이 연습에서는 랩의 필수 구성 요소를 설정합니다. 구체적으로는 [eShopOnWeb](https://github.com/MicrosoftLearning/eShopOnWeb)을 기반으로 하여 새 Azure DevOps 프로젝트와 리포지토리를 설정합니다.

#### 작업 1: (완료된 경우 건너뛰기) 팀 프로젝트 만들기 및 구성

이 작업에서는 여러 랩에서 사용할 **eShopOnWeb** Azure DevOps 프로젝트를 만듭니다.

1. 랩 컴퓨터의 브라우저 창에서 Azure DevOps 조직을 엽니다. **새 프로젝트**를 클릭합니다. 프로젝트 이름을 **eShopOnWeb**으로 설정하고 **작업 항목 프로세스** 드롭다운에서 **스크럼**을 선택합니다. **만들기**를 클릭합니다.

    ![프로젝트 만들기](images/create-project.png)

#### 작업 2: (완료된 경우 건너뛰기) eShopOnWeb Git 리포지토리 가져오기

이 작업에서는 여러 랩에서 사용할 eShopOnWeb Git 리포지토리를 가져옵니다.

1. 랩 컴퓨터의 브라우저 창에서 Azure DevOps 조직 및 이전에 만든 **eShopOnWeb** 프로젝트를 엽니다. **Repos > 파일**, **가져오기**를 클릭합니다. **Git 리포지토리 가져오기** 창에서 다음 URL https://github.com/MicrosoftLearning/eShopOnWeb.git을 붙여넣고 **가져오기**를 클릭합니다.

    ![리포지토리 가져오기](images/import-repo.png)

2. 리포지토리는 다음과 같은 방식으로 구성됩니다.
    - **.ado** 폴더에는 Azure DevOps YAML 파이프라인이 포함되어 있습니다.
    - 컨테이너를 사용(VS Code 또는 GitHub Codespaces에서 로컬로 사용)하여 개발하는 **.devcontainer** 폴더 컨테이너 설정
    - **.azure** 폴더에는 일부 랩 시나리오에서 사용되는 코드 템플릿으로 Bicep&ARM 인프라가 포함되어 있습니다.
    - **.github** 폴더 컨테이너 YAML GitHub 워크플로 정의.
    - **src** 폴더에는 랩 시나리오에서 사용되는 .NET 6 웹 사이트가 포함되어 있습니다.

#### 작업 3: Git 및 Visual Studio Code 설치 및 구성

이 작업에서는 Azure DevOps와 통신하는 데 사용되는 Git 자격 증명을 안전하게 저장하도록 Git 자격 증명 도우미를 구성하는 등 Git 및 Visual Studio Code를 설치하고 구성합니다. 이러한 필수 구성 요소를 이미 구현한 경우 다음 작업으로 직접 진행할 수 있습니다.

1. 랩 컴퓨터에서 Visual Studio Code**를 엽니다**.
2. Visual Studio Code 인터페이스의 주 메뉴에서 **터미널 \| 새 터미널**을 선택하여 **터미널** 창을 엽니다.
3. 터미널 창의 오른쪽 위 모서리**에 있는 드롭다운 목록에 1: powershell**이 표시되는 **경우 검사하여 현재 터미널**이 PowerShell을 실행하고 **있는지 확인합니다.**

    > **참고**: 현재 터미널 셸을 PowerShell**로 **변경하려면 터미널** 창의 **오른쪽 위 모서리에 있는 드롭다운 목록을 클릭하고 기본 셸** 선택을 클릭합니다**. Visual Studio Code 창 위쪽에서 원하는 터미널 셸 **Windows PowerShell** 을 선택하고 드롭다운 목록의 오른쪽에 있는 더하기 기호를 클릭하여 선택한 기본 셸이 있는 새 터미널을 엽니다.

4. **터미널** 창에서 아래 명령을 실행하여 자격 증명 도우미를 구성합니다.

    ```git
    git config --global credential.helper wincred
    ```

5. **터미널** 창에서 다음 명령을 실행하여 Git 커밋용 사용자 이름과 이메일을 구성합니다(괄호 안의 자리 표시자는 < 및 > 기호를 제거하여 원하는 사용자 이름과 이메일로 바꾸면 됩니다).

    ```git
    git config --global user.name "<John Doe>"
    git config --global user.email <johndoe@example.com>
    ```

### 연습 1: 기존 리포지토리 복제

이 연습에서는 Visual Studio Code를 사용하여 이전 연습의 일부로 프로비전한 Git 리포지토리를 복제합니다.

#### 작업 1: 기존 리포지토리 복제

이 작업에서는 Visual Studio Code를 사용하여 Git 리포지토리를 복제하는 프로세스를 단계별로 안내합니다.

1. Azure DevOps 조직 및 이전 연습에서 생성한 **eShopOnWeb** 프로젝트가 표시된 웹 브라우저로 전환합니다.
2. Azure DevOps 포털의 세로 탐색 창에서 Repos** 아이콘을 **선택합니다.

3. **eShopOnWeb** 리포지토리 창 오른쪽 위에서 **복제**를 클릭합니다.

    ![Git 리포지토리 복제](images/clone-repo.png)

    > **참고**: Git 리포지토리의 로컬 복사본을 복제라고 부릅니다**. 모든 기본stream 개발 도구는 이를 지원하며 Azure Repos에 연결하여 작업할 최신 원본을 끌어올 수 있습니다.

4. **복제 리포지토리** 패널**에서 HTTPS** 명령줄 옵션이 선택된 상태에서 리포지토리 복제 URL 옆에 있는 클립보드**로 복사 단추를 클릭합니다**.

    > **참고**: 이 URL을 Git 호환 도구와 함께 사용하여 코드베이스의 복사본을 가져올 수 있습니다.

5. 복제 리포지토리** 패널을 **닫습니다.
6. **랩 컴퓨터에서 실행되는 Visual Studio Code**로 전환합니다.
7. **보기** 메뉴 머리글을 클릭하고 드롭다운 메뉴에서 명령 팔레트**를 클릭합니다**.

    > **참고**: 명령 팔레트는 타사 확장으로 구현된 작업을 포함하여 다양한 작업에 쉽고 편리하게 액세스할 수 있는 방법을 제공합니다. 바로 가기 키 **Ctrl+Shift+P** 또는 **F1** 키를 사용하여 열 수 있습니다.

8. 명령 팔레트 프롬프트에서 Git: Clone** 명령을 실행**합니다.

    ![VS Code 명령 팔레트](images/vscode-command.png)

    > **참고**: 모든 관련 명령을 보려면 Git**을 입력하여 **시작할 수 있습니다.

9. **리포지토리 제공 URL 또는 리포지토리 원본** 텍스트 상자에서 이 작업 앞부분에서 복사한 리포지토리 복제 URL을 붙여넣고 Enter** 키를 누릅니**다.
10. 폴더 선택 대화 상자에서 C: 드라이브로 이동하고, Git**이라는 **새 폴더를 만들고, 선택한 다음, 리포지토리 위치** 선택을 클릭합니다**.** ** 
11. 메시지가 표시되면 Azure DevOps 계정에 로그인합니다.
12. 복제 프로세스가 완료되면 메시지가 표시되면 Visual Studio Code에서 열기**를 클릭하여 **복제된 리포지토리를 엽니다.

    > **참고**: 프로젝트 로드와 관련된 문제가 발생할 수 있는 경고를 무시할 수 있습니다. 솔루션이 빌드에 적합한 상태가 아닐 수도 있지만 Git 작업에 집중할 것이므로 프로젝트를 빌드할 필요가 없습니다.

### 연습 2: 커밋으로 작업 저장

이 연습에서는 Visual Studio Code를 사용하여 변경 내용을 스테이징하고 커밋하는 몇 가지 시나리오를 단계별로 설명합니다.

파일을 변경하면 Git에서 변경 내용을 로컬 리포지토리에 기록합니다. 커밋하려는 변경 내용을 스테이징하여 선택할 수 있습니다. 커밋은 항상 로컬 Git 리포지토리에 대해 만들어지므로 커밋이 완벽하거나 다른 사용자와 공유할 준비가 된 것에 대해 걱정할 필요가 없습니다. 계속 작업하면서 더 많은 커밋을 수행하고 공유 준비가 되면 변경 내용을 다른 사용자에게 푸시할 수 있습니다.

Git 커밋은 다음으로 구성됩니다.

- 커밋에서 파일이 변경되었습니다. Git은 리포지토리의 모든 파일 변경 내용 내용을 커밋에 유지합니다. 이렇게 하면 속도가 빨라지고 지능형 병합이 가능합니다.
- 부모 커밋에 대한 참조입니다. Git은 이러한 참조를 사용하여 코드 기록을 관리합니다.
- 커밋을 설명하는 메시지입니다. 커밋을 만들 때 Git에 이 메시지를 제공합니다. 이 메시지를 설명적으로 유지하는 것이 좋지만, 그 시점까지는 좋은 생각입니다.

#### 작업 1: 변경 내용 커밋

이 작업에서는 Visual Studio Code를 사용하여 변경 내용을 커밋합니다.

1. Visual Studio Code 창의 세로 도구 모음 위쪽에서 **탐색기** 탭을 선택하고 **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하여 해당 파일을 선택합니다. 그러면 세부 정보 창에 해당 콘텐츠가 자동으로 표시됩니다.
2. 첫 번째 줄에 다음 주석을 추가합니다.

    ```csharp
    // My first change
    ```

    > **참고**: 단순히 변경하는 것이 목표이기 때문에 주석이 무엇인지는 중요하지 않습니다.

3. Ctrl+S**를 눌러 **변경 사항을 저장합니다.
4. Visual Studio Code 창에서 소스 제어** 탭을 선택하여 **Git이 Git 리포지토리의 로컬 복제본에 있는 파일에 대한 최신 변경 내용을 인식했는지 확인합니다.
5. 소스 제어** 탭을 **선택한 상태에서 창 위쪽의 텍스트 상자에 내 커밋**을 커밋 메시지 입력**하고 Ctrl+Enter**를 눌러 **로컬로 커밋합니다.

    ![첫 번째 커밋](images/first-commit.png)

6. 변경 내용을 자동으로 스테이징하고 직접 커밋할지 묻는 메시지가 표시되면 [항상 **]을 클릭합니다**.

    > **참고**: 랩의 뒷부분에서 준비**에 대해 설명**합니다.

7. Visual Studio Code 창 왼쪽 아래의 **main** 레이블 오른쪽에는 **변경 내용 동기화** 아이콘(서로 반대 방향을 가리키는 세로 화살표 2개가 들어 있는 원 모양)이 있고, 위쪽 화살표 옆에는 숫자 **1**이 표시됩니다. 이 아이콘을 클릭하고 계속 진행할지를 묻는 메시지가 표시되면 **확인**을 클릭하여 **origin/main**과의 커밋 푸시 및 풀을 진행합니다.

#### 작업 2: 커밋 검토

이 작업에서는 Azure DevOps 포털을 사용하여 커밋을 검토합니다.

1. Azure DevOps 인터페이스를 표시하는 웹 브라우저 창으로 전환합니다.
2. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos** 섹션에서**커밋**을 선택합니다.
3. 커밋이 목록 맨 위에 표시되는지 확인합니다.

    ![ADO 리포지토리 커밋](images/ado-commit.png)

#### 작업 3: 단계 변경

이 작업에서는 Visual Studio Code를 사용하여 스테이징 변경 내용의 사용을 탐색합니다. 스테이징 변경 내용을 사용하면 다른 파일에서 변경한 내용을 전달하면서 특정 파일을 커밋에 선택적으로 추가할 수 있습니다.

1. **Visual Studio Code** 창으로 다시 전환합니다.
2. 첫 번째 주석을 다음으로 변경하고 파일을 저장하여 열려 있는 **Program.cs** 클래스를 업데이트합니다.

    ```csharp
        //My second change
    ```

3. Visual Studio Code 창에서 **탐색기** 탭으로 다시 전환한 후 **/eShopOnWeb/src/Web/Constants.cs** 파일로 이동하고 해당 파일을 선택합니다. 그러면 세부 정보 창에 해당 콘텐츠가 자동으로 표시됩니다.
4. **Constants.cs** 파일의 첫 번째 줄에 주석을 추가하고 파일을 저장합니다.

    ```csharp
    // My third change
    ```

5. Visual Studio Code 창에서 **소스 제어** 탭으로 전환하여 **Program.cs** 항목 위에 마우스 포인터를 놓고 해당 항목 오른쪽의 더하기 기호를 클릭합니다.

    > **참고**: 이 작업을 수행하면 **Program.cs** 파일의 변경 내용만 스테이징되어 커밋 가능하도록 준비되며 **Constants.cs**는 준비되지 않습니다.

6. 소스 제어** 탭을 **선택한 상태에서 창 맨 위에 있는 텍스트 상자에 추가된 주석을 커밋 메시지 입력**합니다**.

    ![스테이징된 변경 내용](images/staged-changes.png)

7. 소스 제어 탭의 **위쪽에서 줄임표 기호를 클릭하고 드롭다운 메뉴에서 커밋**을 선택하고 **계단식 메뉴에서 스테이징** 커밋을 선택합니다**.**
8. Visual Studio Code 창 왼쪽 아래에서 **변경 내용 동기화** 단추를 클릭하여 커밋된 변경 내용을 서버와 동기화합니다. 계속 진행할지를 묻는 메시지가 표시되면 **확인**을 클릭하여 **origin/main**과의 커밋 푸시 및 풀을 진행합니다.

    > **참고**: 준비된 변경 내용만 커밋되었으므로 다른 변경 내용은 여전히 동기화 보류 중입니다.

### 연습 3: 기록 검토

이 연습에서는 Azure DevOps 포털을 사용하여 커밋 기록을 검토합니다.

Git은 각 커밋에 저장된 부모 참조 정보를 사용하여 개발의 전체 기록을 관리합니다. 이 커밋 기록을 쉽게 검토하여 파일 변경이 수행된 시기를 확인하고 터미널을 사용하는 코드 버전 또는 사용 가능한 여러 Visual Studio Code 확장 중 하나에서 차이점을 확인할 수 있습니다. Azure DevOps 포털을 사용하여 변경 내용을 검토할 수도 있습니다.

Git의 분기 및 병합 기능 사용 **은** 끌어오기 요청을 통해 작동하므로 개발의 커밋 기록이 반드시 연속적인 시간순 선을 형성하지는 않습니다. 기록을 사용하여 버전을 비교할 때 두 시간 사이의 파일 변경 대신 두 커밋 간의 파일 변경 내용을 고려해야 합니다. 기본 분기의 파일에 대한 최근 변경 내용은 어제 병합된 기능 분기 2주 전에 만든 커밋에서 나온 것일 수 있습니다.

#### 작업 1: 파일 비교

이 작업에서는 Azure DevOps 포털을 사용하여 커밋 기록을 단계별로 진행합니다.

1. Visual Studio Code 창에서 **소스 제어** 탭을 연 상태로 파일의 스테이징되지 않은 버전을 나타내는 **Constants.cs**를 선택합니다.

    ![파일 비교](images/file-comparison.png)

    > **참고**: 변경 내용을 쉽게 찾을 수 있도록 비교 보기가 열립니다. 이 경우 하나의 메모에 불과합니다.

2. Azure DevOps**** 포털의 **커밋 창을 표시하는 **웹 브라우저 창으로 전환하여 원본 분기 및 병합을 검토합니다. 이렇게 하면 원본이 변경된 시기와 방법을 편리하게 시각화할 수 있습니다.
3. 아래쪽의 **내 커밋** 항목(이전에 푸시한 항목)으로 스크롤한 다음 해당 항목 위에 마우스 포인터를 놓으면 오른쪽에 줄임표 기호가 표시됩니다.
4. 줄임표를 클릭하고 드롭다운 메뉴에서 파일** 찾아보기를 선택하고 **결과를 검토합니다.

    ![커밋 찾아보기](images/commit-browse.png)

    > **참고**: 이 뷰는 커밋에 해당하는 원본의 상태를 나타내며, 각 원본 파일을 검토하고 다운로드할 수 있습니다.

### 연습 4: 분기 작업

이 연습에서는 Visual Studio Code 및 Azure DevOps 포털을 사용하여 분기 관리를 포함하는 시나리오를 단계별로 안내합니다.

Azure DevOps 포털의 Azure Repos** 분기** 보기**에서 **Azure DevOps Git 리포지토리에서 관리할 수 있습니다. 또한 뷰를 사용자 지정하여 가장 관심 있는 분기를 추적할 수 있으므로 팀에서 변경한 내용을 파악할 수 있습니다.

분기 변경 내용을 커밋하면 다른 분기에는 영향을 주지 않으며 변경 내용을 기본 프로젝트에 병합하지 않고도 다른 분기와 분기를 공유할 수 있습니다. 기본 분기 및 기타 작업에서 기능 또는 버그 수정에 대한 변경 내용을 격리하는 새 분기를 만들 수도 있습니다. 분기는 경량이므로 분기 간 전환은 빠르고 쉽습니다. Git은 분기를 사용할 때 원본의 복사본을 여러 개 만들지 않고 커밋에 저장된 기록 정보를 사용하여 작업을 시작할 때 분기의 파일을 다시 만듭니다. Git 워크플로는 기능 및 버그 수정을 관리하기 위해 분기를 만들고 사용해야 합니다. 코드 공유 및 끌어오기 요청으로 코드 검토와 같은 Git 워크플로의 나머지 작업은 모두 분기를 통해 작동합니다. 분기에서 작업을 격리하면 현재 분기를 변경하기만 하면 작업 중인 작업을 매우 간단하게 변경할 수 있습니다.

#### 작업 1: 로컬 리포지토리에 새 분기 만들기

이 작업에서는 Visual Studio Code를 사용하여 분기를 만듭니다.

1. **랩 컴퓨터에서 실행되는 Visual Studio Code**로 전환합니다.
2. **소스 제어** 탭을 선택한 상태로 Visual Studio Code 창 왼쪽 아래에서 **main**을 클릭합니다.
3. 팝업 창에서 + 새 분기 만들기...**를 선택합니다**.

    ![분기 만들기](images/create-branch.png)

4. **분기 이름** 텍스트 상자에 dev**를 입력**하여 새 분기를 지정하고 Enter 키를 누릅니**다**.
5. **'dev' 분기를 만들 참조 선택** 텍스트 상자에서 참조 분기로 **main**을 선택합니다.

    > **참고**: 이 시점에서 개발 분기로 **** 자동으로 전환됩니다.

#### 작업 2: 분기 삭제

이 작업에서는 Visual Studio Code를 사용하여 이전 작업에서 만든 분기로 작업합니다.

Git은 작업 중인 분기를 추적하고 분기를 검사 때 파일이 해당 분기의 가장 최근 커밋과 일치하는지 확인합니다. 분기를 사용하면 동일한 로컬 Git 리포지토리에서 여러 버전의 소스 코드를 동시에 사용할 수 있습니다. Visual Studio Code를 사용하여 분기를 게시, 검사 삭제할 수 있습니다.

1. **Visual Studio Code** 창**에서 소스 제어** 탭이 선택된 상태에서 Visual Studio Code 창의 왼쪽 아래 모서리에서 변경 내용** 게시 아이콘(새로 만든 분기를 나타내는 개발** 레이블의 **오른쪽에 있는 직접)을 클릭합니다**.
2. Azure DevOps 포털의 **커밋 창을 표시하는 **웹 브라우저 창으로 전환하고 분기**를 선택합니다**.****
3. **분기 창의 광산** 탭에서 **분기** 목록에 dev가 포함되어 **있는지 확인합니다**.
4. 마우스 포인터를 **개발** 분기 항목 위로 가리키면 오른쪽에 줄임표 기호가 표시됩니다.
5. 줄임표를 클릭하고 팝업 메뉴에서 분기** 삭제를 선택하고 **확인 메시지가 표시되면 삭제**를 클릭합니다**.

    ![분기 삭제](images/delete-branch.png)

6. Visual Studio Code 창으로 **다시 전환하고 소스 제어** 탭이 선택된 상태에서 **Visual Studio Code 창의 왼쪽 아래 모서리에서 개발** 항목을 클릭합니다**.** 그러면 Visual Studio Code 창의 위쪽에 기존 분기가 표시됩니다.
7. 이제 두 개의 **개발** 분기가 나열되어 있는지 확인합니다.

    > **참고**: 로컬(**개발**) 분기는 원격 리포지토리 분기 삭제의 영향을 받지 않으므로 나열됩니다. 서버(**origin/dev**) 분기는 정리되지 않았으므로 목록에 표시됩니다.

8. 분기 목록에서 **main** 분기를 선택하여 체크 아웃합니다.
9. Ctrl+Shift+P를 눌러 **명령 팔레트**를 **엽니다.**
10. **명령 팔레트** 프롬프트에서 Git 입력 **시작: Git 삭제** 및 Git: 분기**가 표시되면 분기 삭제를 선택합니다**.
11. 삭제할 **분기 목록에서 개발** 항목을 선택합니다.
12. Visual Studio Code 창 왼쪽 아래에서 **main** 항목을 다시 클릭합니다. 그러면 Visual Studio Code 창의 위쪽에 기존 분기가 표시됩니다.
13. 로컬 **개발** 분기가 목록에 더 이상 표시되지 않지만 원격 **원본/개발** 이 여전히 있는지 확인합니다.
14. Ctrl+Shift+P를 눌러 **명령 팔레트**를 **엽니다.**
15. **명령 팔레트** 프롬프트에서 Git 입력을 **시작하고, Git: Fetch****(정리)** 가 표시되면 선택합니다.

    > **참고**: 이 명령은 로컬 스냅샷 원본 분기를 업데이트하고 더 이상 없는 분기를 삭제합니다.

    > **참고**: Visual Studio Code 창의 오른쪽 아래에 있는 출력** 창을 선택하여 **이러한 작업이 수행하는 작업을 정확히 검사 수 있습니다. 출력 콘솔에 Git 로그가 표시되지 않는 경우 Git**을 원본으로 선택**해야 합니다.

16. Visual Studio Code 창 왼쪽 아래에서 **main** 항목을 다시 클릭합니다.
17. 원본/개발** 분기가 **분기 목록에 더 이상 표시되지 않는지 확인합니다.

#### 작업 3: 분기 복원

이 작업에서는 Azure DevOps 포털을 사용하여 이전 작업에서 삭제한 분기를 복원합니다.

1. Azure DevOps 포털의 **분기** 창 **내 항목** 탭이 표시된 웹 브라우저로 전환합니다.
2. **분기** 창의 [마이닝]** 탭에서 **[모두 **] 탭을 **선택합니다.
3. **분기** 창의 **모두** 탭에 있는 **분기 이름 검색** 텍스트 상자에 **dev**를 입력합니다.
4. **새로 삭제된 분기**를 나타내는 항목이 포함된 지운 분기 섹션을 검토합니다.
5. **삭제된 분기** 섹션에서 **dev** 분기 항목 위에 마우스 포인터를 올리면 오른쪽에 줄임표 기호가 표시됩니다.
6. 팝업 메뉴에서 줄임표를 클릭하고 **분기 복원**을 선택합니다.

    ![분기 복원](images/restore-branch.png)

    > **참고**: 이 기능을 사용하여 정확한 이름을 알고 있는 한 삭제된 분기를 복원할 수 있습니다.

#### 작업 4: 분기 정책

이 작업에서는 Azure DevOps 포털을 사용하여 기본 분기에 정책을 추가하며, 정의된 정책을 준수하는 끌어오기 요청을 사용하는 변경 내용만 허용합니다. 분기의 변경 내용을 병합하기 전에 해당 변경 내용을 검토하려 합니다.

간단한 작업을 위해 VS Code에서 로컬 클론을 사용하는 대신, 웹 브라우저 리포지토리 편집기에서 직접 작업(원본에서 직접 작업)합니다. 이는 실제 시나리오에 권장됩니다.

1. Azure DevOps 포털에서 **분기** 창의 마이닝** 탭을 **표시하는 웹 브라우저로 전환합니다.
2. **분기** 창의 **내 항목** 탭에서 **main** 분기 항목 위에 마우스 포인터를 올리면 오른쪽에 줄임표 기호가 표시됩니다.
3. 줄임표를 클릭하고 팝업 메뉴에서 **분기 정책**을 선택합니다.

    ![분기 정책](images/branch-policies.png)

4. 리포지토리 설정의 **main** 탭에서 **최소 검토자 수 필요** 옵션을 사용하도록 설정합니다. 검토자 **1**명을 추가하고 **요청자가 자신의 변경 내용을 승인할 수 있음**(현재 수강생 본인이 랩 프로젝트의 유일한 사용자이므로) 확인란을 선택합니다.
5. 리포지토리 설정의 **main** 탭에서 **연결된 작업 항목 확인** 옵션을 사용하도록 설정하고 **필수** 옵션으로 그대로 둡니다.

    ![정책 설정](images/policy-settings.png)

#### 작업 5: 분기 정책 테스트

이 작업에서는 Azure DevOps 포털을 사용하여 정책을 테스트하고 첫 번째 끌어오기 요청을 만듭니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos > 파일**에서 **main** 분기가 선택되어 있는지 확인합니다(표시된 콘텐츠 위의 드롭다운).
2. 정책이 작동하는지 확인하려면 변경 내용을 적용하고 **main** 분기에서 커밋한 다음, **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하고 해당 파일을 선택합니다. 그러면 세부 정보 창에 해당 콘텐츠가 자동으로 표시됩니다.
3. 첫 번째 줄에 다음 주석을 추가합니다.

    ```csharp
    // Testing main branch policy
    ```

4. **커밋 > 커밋**을 클릭합니다. 경고가 표시됩니다. 기본 분기를 변경하는 건 끌어오기 요청을 사용하는 경우에만 가능합니다.

    ![정책 거부 커밋](images/policy-denied.png)

5. **취소**를 클릭하여 커밋을 건너뜁니다.

#### 작업 6: 끌어오기 요청 작업

이 작업에서는 Azure DevOps 포털을 사용하여 끌어오기 요청을 만듭니다. 끌어오기 요청은 **dev** 분기를 사용하여 변경 내용을 보호된 **main** 분기에 병합합니다. Azure DevOps 작업 항목은 코드 작업으로 보류 중인 작업을 추적할 수 있도록 변경 내용에 연결됩니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Boards** 섹션에서 **작업 항목**을 선택합니다.
2. **+ 새 작업 항목 > 제품 백로그 항목**을 클릭합니다. 제목 필드에 **내 첫 번째 PR 테스트**라고 작성한 후 **저장**을 클릭합니다.
3. 이제 Azure DevOps 포털의 세로 탐색 창으로 돌아간 다음, **Repos > 파일**에서 **dev** 분기가 선택되어 있는지 확인합니다.
4. **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하여 첫 번째 줄에서 다음을 변경합니다.

    ```csharp
    // Testing my first PR
    ```

5. **커밋 > 커밋**을 클릭합니다(기본 커밋 메시지는 그대로 둠). 이번에는 커밋이 작동하며 **dev** 분기에는 정책이 없습니다.
6. 끌어오기 요청을 만들도록 제안하는 메시지가 팝업 창에 표시됩니다. 이제 **dev** 분기가 **main**과 비교하여 변경 내용에서 앞서 있기 때문입니다. **끌어오기 요청 만들기**를 클릭합니다.

    ![끌어오기 요청 만들기](images/create-pr.png)

7. **새 끌어오기 요청** 탭에서 기본값은 그대로 두고 **만들기**를 클릭합니다.
8. 대상 **main** 분기에 적용된 정책에 따라, 끌어오기 요청에는 몇 가지 실패/보류 중인 요구 사항이 표시됩니다.
    - 제안된 변경 내용에 연결된 작업 항목이 있어야 합니다.
    - 1명 이상의 사용자가 변경 내용을 검토하고 승인해야 합니다.

9. 오른쪽 옵션에서 **작업 항목** 옆의 **+** 단추를 클릭합니다. 이전에 만든 작업 항목을 클릭하여 끌어오기 요청에 연결합니다. 요구 사항의 변경 상태 중 하나가 표시됩니다.

    ![작업 항목 연결](images/link-wit.png)

10. 그 다음, **파일** 탭을 열어 제안된 변경 내용을 검토합니다. 추가 끌어오기 요청 완료에서는 파일을 하나씩 검토하고(검토된 것으로 표시됨), 명확하지 않은 줄에 대한 주석을 열어볼 수 있습니다(줄 번호 위에 마우스를 올리면 주석을 게시할 수 있는 옵션이 제공됨).
11. **개요** 탭으로 돌아간 후 오른쪽 상단에서 **승인**을 클릭합니다. 모든 요구 사항이 녹색으로 변경됩니다. 이제 **완료**를 클릭할 수 있습니다.
12. **끌어오기 요청 완료** 탭에서는 병합을 완료하기 전에 여러 옵션이 제공됩니다.
    - **병합 형식**: 4가지 병합 형식이 제공되며, [여기에서](https://learn.microsoft.com/azure/devops/repos/git/complete-pull-requests?view=azure-devops&tabs=browser#complete-a-pull-request)이를 검토하거나 제공된 애니메이션을 확인할 수 있습니다. **병합(빨리 감기 안 함)** 을 선택합니다.
    - **완료 후 옵션**:
        - **연결된 작업 항목 완료...** 를 선택합니다. 이렇게 하면 연결된 PBI가 **완료** 상태로 이동합니다.

13. **병합 완료**를 클릭합니다.

#### 작업 7: 태그 적용

제품 팀은 사이트의 현재 버전을 v1.1.0 베타로 릴리스하기로 결정했습니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos** 섹션에서 태그를** 선택합니다**.
2. **태그** 창에서 새 태그**를 클릭합니다**.
3. **태그 만들기**패널의 **이름** 텍스트 상자에 **v1.1.0-beta**를 입력하고 **기준** 드롭다운 목록에서는 **main** 항목을 그대로 선택해 둡니다. **설명** 텍스트 상자에는 **베타 릴리스 v1.1.0**을 입력하고 **만들기**를 클릭합니다.

    > **참고**: 이제 이 릴리스에서 리포지토리에 태그를 지정했습니다(최신 커밋이 태그에 연결됨). 다양한 이유로 커밋에 태그를 지정할 수 있으며 Azure DevOps는 권한을 관리할 뿐만 아니라 편집 및 삭제할 수 있는 유연성을 제공합니다.

## 검토

이 랩에서는 Azure DevOps 포털을 사용하여 분기 및 리포지토리를 관리했습니다.
