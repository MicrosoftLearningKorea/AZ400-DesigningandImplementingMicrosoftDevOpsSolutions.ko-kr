---
lab:
  title: Azure Repos에서 Git를 사용하여 버전 제어
  module: 'Module 02: Work with Azure Repos and GitHub'
---

# <a name="version-controlling-with-git-in-azure-repos"></a>Azure Repos에서 Git를 사용하여 버전 제어

# <a name="student-lab-manual"></a>학생용 랩 매뉴얼

## <a name="lab-requirements"></a>랩 요구 사항

- 이 랩은 **Microsoft Edge** 또는 [Azure DevOps 지원 브라우저](https://docs.microsoft.com/en-us/azure/devops/server/compatibility?view=azure-devops#web-portal-supported-browsers)가 필요합니다.

- **Azure DevOps 조직 설정:** 이 랩에 사용할 수 있는 Azure DevOps 조직이 아직 없으면 [조직 또는 프로젝트 컬렉션 만들기](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/create-organization?view=azure-devops)에서 제공되는 지침에 따라 조직을 만듭니다.

- Git 2.29.2 이상을 아직 설치하지 않았다면 웹 브라우저를 시작하고 [Windows용 Git 다운로드 페이지](https://gitforwindows.org/)로 이동하여 Git를 다운로드한 다음 설치합니다.
- Visual Studio Code를 아직 설치하지 않았다면 웹 브라우저 창에서 [Visual Studio Code 다운로드 페이지](https://code.visualstudio.com/)로 이동하여 Visual Studio Code를 다운로드한 다음 설치합니다.
- Visual Studio C# 확장을 아직 설치하지 않았다면 웹 브라우저 창에서 [C# 확장 설치 페이지](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)로 이동하여 확장을 설치합니다.

## <a name="lab-overview"></a>랩 개요

Azure DevOps에서는 두 가지 유형의 버전 제어가 지원됩니다. 그 중 하나는 Git를 사용한 제어이고 다른 하나는 TFVC(Team Foundation 버전 제어)를 통한 제어입니다. 이 두 가지 버전 제어 시스템의 기능을 요약하여 설명하자면 다음과 같습니다.

- **TFVC(Team Foundation 버전 제어)** : TFVC는 중앙 집중식 버전 제어 시스템입니다. 일반적으로 팀 멤버는 자신의 고유 개발 컴퓨터에 각 파일 버전 하나만 보유합니다. 기록 데이터는 서버에만 보관됩니다. 분기는 경로에 기반을 두며 서버에서 만들어집니다.

- **Git**: Git는 분산 버전 제어 시스템입니다. 개발자 머신 등의 로컬 환경에 Git 리포지토리를 저장할 수 있습니다. 각 개발자는 자신의 개발 컴퓨터에 소스 리포지토리의 복사본을 가지고 있습니다. 개발자는 자신의 개발 컴퓨터에서 각 변경 내용 집합을 커밋하고 네트워크 연결 없이 기록 및 비교와 같은 버전 제어 작업을 수행할 수 있습니다.

신규 프로젝트의 기본 버전 제어 공급자는 Git입니다. TFVC의 중앙 집중식 버전 제어 기능이 필요한 경우가 아니면 프로젝트 버전 제어에 Git을 사용해야 합니다.

이 랩에서는 Azure DevOps의 중앙 집중식 Git 리포지토리와 쉽게 동기화할 수 있는 로컬 Git 리포지토리를 설정하는 방법을 배웁니다. 또한 Git 분기 지정 및 병합 지원에 대해서도 알아봅니다. 여기서는 Visual Studio Code를 사용하지만 어떤 Git 호환 클라이언트를 사용하든 프로세스는 동일합니다.

## <a name="objectives"></a>목표

이 랩을 완료하면 다음 작업을 수행할 수 있습니다.

- 기존 리포지토리를 복제합니다.
- 커밋으로 작업을 저장합니다.
- 변경 기록을 검토합니다.
- Visual Studio Code를 통해 분기를 사용합니다.

## <a name="estimated-timing-60-minutes"></a>예상 소요 시간: 60분

## <a name="instructions"></a>Instructions

### <a name="exercise-0-configure-the-lab-prerequisites"></a>연습 0: 랩 필수 구성 요소 구성

이 연습에서는 랩의 필수 구성 요소를 설정합니다. 구체적으로는 [eShopOnWeb](https://github.com/MicrosoftLearning/eShopOnWeb)을 기반으로 하여 새 Azure DevOps 프로젝트와 리포지토리를 설정합니다.

#### <a name="task-1-skip-if-done-create-and-configure-the-team-project"></a>작업 1: (완료된 경우 건너뛰기) 팀 프로젝트 만들기 및 구성

이 작업에서는 여러 랩에서 사용할 **eShopOnWeb** Azure DevOps 프로젝트를 만듭니다.

1.  랩 컴퓨터의 브라우저 창에서 Azure DevOps 조직을 엽니다. **새 프로젝트**를 클릭합니다. 프로젝트 이름을 **eShopOnWeb**으로 설정하고 **작업 항목 프로세스** 드롭다운에서 **스크럼**을 선택합니다. **만들기**를 클릭합니다.

    ![프로젝트 만들기](images/create-project.png)

#### <a name="task-2-skip-if-done-import-eshoponweb-git-repository"></a>작업 2: (완료된 경우 건너뛰기) eShopOnWeb Git 리포지토리 가져오기

이 작업에서는 여러 랩에서 사용할 eShopOnWeb Git 리포지토리를 가져옵니다.

1.  랩 컴퓨터의 브라우저 창에서 Azure DevOps 조직 및 이전에 만든 **eShopOnWeb** 프로젝트를 엽니다. **Repos > 파일**, **가져오기**를 클릭합니다. **Git 리포지토리 가져오기** 창에서 다음 URL https://github.com/MicrosoftLearning/eShopOnWeb.git 을 붙여넣고 **가져오기**를 클릭합니다.

    ![리포지토리 가져오기](images/import-repo.png)

1.  리포지토리는 다음과 같은 방식으로 구성됩니다.
    - **.ado** 폴더에는 Azure DevOps YAML 파이프라인이 포함되어 있습니다.
    - 컨테이너를 사용(VS Code 또는 GitHub Codespaces에서 로컬로 사용)하여 개발하는 **.devcontainer** 폴더 컨테이너 설정
    - **.azure** 폴더에는 일부 랩 시나리오에서 사용되는 코드 템플릿으로 Bicep&ARM 인프라가 포함되어 있습니다.
    - **.github** 폴더 컨테이너 YAML GitHub 워크플로 정의.
    - **src** 폴더에는 랩 시나리오에서 사용되는 .NET 6 웹 사이트가 포함되어 있습니다.

#### <a name="task-3-configure-git-and-visual-studio-code"></a>작업 3: Git 및 Visual Studio Code 설치 및 구성

이 작업에서는 Git 및 Visual Studio Code를 설치하고 구성합니다. 이 과정에서 Azure DevOps와 통신하는 데 사용되는 Git 자격 증명을 안전하게 저장하기 위해 Git 자격 증명 도우미를 구성합니다. 이 필수 구성 요소를 이미 구현한 경우에는 다음 작업을 바로 진행해도 됩니다.

1. 랩 컴퓨터에서 **Visual Studio Code**를 엽니다.
1. Visual Studio Code 인터페이스의 주 메뉴에서 **터미널 \| 새 터미널**을 선택하여 **터미널** 창을 엽니다.
1. 현재 터미널에서 **PowerShell**을 실행 중인지 확인합니다. 이렇게 하려면 **터미널** 창 오른쪽 위의 드롭다운 목록에 **1: powershell**이 표시되어 있는지 확인합니다.

    > **참고**: 현재 터미널 셸을 **PowerShell**로 변경하려면 **터미널** 창 오른쪽 위의 드롭다운 목록을 클릭하고 **기본 셸 선택**을 클릭합니다. Visual Studio Code 창 위쪽에서 기본 설정 셸로 **Windows PowerShell**을 선택하고 드롭다운 목록 오른쪽의 더하기 기호를 클릭하여 선택한 기본 셸이 표시된 새 터미널을 엽니다.

1. **터미널** 창에서 다음 명령을 실행하여 자격 증명 도우미를 구성합니다.

    ```git
    git config --global credential.helper wincred
    ```

1. **터미널** 창에서 다음 명령을 실행하여 Git 커밋용 사용자 이름과 이메일을 구성합니다(괄호 안의 자리 표시자는 < 및 > 기호를 제거하여 원하는 사용자 이름과 이메일로 바꾸면 됩니다).

    ```git
    git config --global user.name "<John Doe>"
    git config --global user.email <johndoe@example.com>
    ```

### <a name="exercise-1-clone-an-existing-repository"></a>연습 1: 기존 리포지토리 복제

이 연습에서는 Visual Studio Code를 사용하여 이전 연습에서 프로비전한 Git 리포지토리를 복제합니다.

#### <a name="task-1-clone-an-existing-repository"></a>작업 1: 기존 리포지토리 복제

이 작업에서는 Visual Studio Code를 사용하여 Git 리포지토리를 복제하는 프로세스를 단계별로 진행합니다.

1. Azure DevOps 조직 및 이전 연습에서 생성한 **eShopOnWeb** 프로젝트가 표시된 웹 브라우저로 전환합니다.
1. Azure DevOps 포털의 세로 탐색 창에서 **Repos** 아이콘을 선택합니다.

1. **eShopOnWeb** 리포지토리 창 오른쪽 위에서 **복제**를 클릭합니다.

    ![Git 리포지토리 복제](images/clone-repo.png)

    > **참고**: *복제*는 Git 리포지토리의 로컬 복사본을 가져오는 작업입니다. 현재 널리 사용되고 있는 모든 개발 도구에서는 복제가 지원됩니다. 즉, Azure Repos에 연결하여 사용할 최신 원본을 가져올 수 있습니다.

2. **리포지토리 복제** 창에서 **HTTPS** 명령줄 옵션을 선택하고 리포지토리 복제 URL 옆의 **클립보드에 복사** 단추를 클릭합니다.

    > **참고**: 모든 Git 호환 도구에서 이 URL을 사용하여 코드베이스 복사본을 가져올 수 있습니다.

3. **리포지토리 복제** 창을 닫습니다.
4. 랩 컴퓨터에서 실행 중인 **Visual Studio Code**로 전환합니다.
5. **보기** 메뉴 머리글을 클릭하고 드롭다운 메뉴에서 **명령 팔레트**를 클릭합니다.

    > **참고**: 명령 팔레트에서는 타사 확장으로 구현되는 작업을 비롯하여 다양한 작업에 쉽고 편리하게 액세스할 수 있습니다. **Ctrl+Shift+P** 바로 가기 키나 **F1** 키를 사용하여 명령 팔레트를 열 수 있습니다.

6. 명령 팔레트 프롬프트에서 **Git: Clone** 명령을 실행합니다.

    ![VS Code 명령 팔레트](images/vscode-command.png)

    > **참고**: 관련 명령을 모두 확인하려는 경우 **Git**부터 입력을 시작하면 됩니다.

7. **리포지토리 URL을 입력하거나 리포지토리 원본 선택** 텍스트 상자에 이 작업 앞부분에서 복사한 리포지토리 복제 URL을 붙여넣고 **Enter** 키를 누릅니다.
8. **폴더 선택** 대화 상자 내에서 C: 드라이브로 이동하여 새 폴더 **Git**를 만들고 선택한 다음 **리포지토리 위치 선택**을 클릭합니다.
9. 메시지가 표시되면 Azure DevOps 계정에 로그인합니다.
10. 복제 프로세스가 완료된 후 메시지가 표시되면 Visual Studio Code에서 **열기**를 클릭하여 복제된 리포지토리를 엽니다.

    > **참고**: 프로젝트 로드 문제와 관련하여 표시될 수 있는 경고는 무시해도 됩니다. 솔루션이 빌드에 적합한 상태가 아닐 수도 있습니다. 하지만 여기서는 Git 사용 방법만 중점적으로 확인할 것이므로 프로젝트는 빌드하지 않아도 됩니다.

### <a name="exercise-2-save-work-with-commits"></a>연습 2: 커밋으로 작업 저장

이 연습에서는 Visual Studio Code를 사용하여 변경 내용을 스테이징 및 커밋하는 여러 시나리오를 단계별로 진행합니다.

파일을 변경하면 Git에서 로컬 리포지토리에 변경 내용을 기록합니다. 커밋하려는 변경 내용은 "스테이징"을 통해 선택할 수 있습니다. 커밋은 항상 로컬 Git 리포지토리를 대상으로 진행되므로 변경이 완료되었거나 다른 사용자들과 공유 가능한 내용을 커밋해야 하는 것은 아닙니다. 작업을 진행하면서 추가로 커밋을 실행할 수 있으며, 변경 내용을 공유할 준비가 되면 다른 사용자들에게 해당 내용을 푸시할 수 있습니다.

Git 커밋의 구성 요소는 다음과 같습니다.

- 커밋에서 변경되는 파일. Git에서는 커밋 시에 모든 파일 변경 내용을 리포지토리에 보관합니다. 그러므로 변경 내용이 빠르게 저장되며, 지능형 병합이 가능합니다.
- 상위 커밋에 대한 참조. Git에서는 이러한 참조를 사용해 코드 기록을 관리합니다.
- 커밋을 설명하는 메시지. 커밋 작성 시 Git에 이 메시지를 제공합니다. 그러므로 커밋의 요점을 설명하는 정보를 이 메시지에 포함하는 것이 좋습니다.

#### <a name="task-1-commit-changes"></a>작업 1: 변경 내용 커밋

이 작업에서는 Visual Studio Code를 사용하여 변경 내용을 커밋합니다.

1. Visual Studio Code 창의 세로 도구 모음 위쪽에서 **탐색기** 탭을 선택하고 **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하여 해당 파일을 선택합니다. 그러면 세부 정보 창에 파일 내용이 자동으로 표시됩니다.
1. 첫 번째 줄에 다음 주석을 추가합니다.

    ```csharp
    // My first change
    ```

    > **참고**: 여기서는 파일을 변경만 하면 되므로 주석의 내용은 상관이 없습니다.

1. **Ctrl+S** 를 눌러 변경 내용을 저장합니다.
1. Visual Studio Code 창에서 **소스 제어** 탭을 선택하여 Git에서 Git 리포지토리 로컬 복제본에 있는 파일의 최신 변경 내용을 인식했는지 확인합니다.
1. **소스 제어** 탭을 선택한 상태로 창 위쪽의 텍스트 상자에 커밋 메시지로 **My commit**을 입력하고 **Ctrl+Enter**를 눌러 로컬에서 변경 내용을 커밋합니다.

    ![첫 번째 커밋](images/first-commit.png)

1. 변경 내용을 자동으로 스테이징하여 바로 커밋할 것인지를 묻는 메시지가 표시되면 **항상**을 클릭합니다.

    > **참고**: **스테이징** 과정에 대해서는 이 랩 뒷부분에서 설명합니다.

1. Visual Studio Code 창 왼쪽 아래의 **main** 레이블 오른쪽에는 **변경 내용 동기화** 아이콘(서로 반대 방향을 가리키는 세로 화살표 2개가 들어 있는 원 모양)이 있고, 위쪽 화살표 옆에는 숫자 **1**이 표시됩니다. 이 아이콘을 클릭하고 계속 진행할지를 묻는 메시지가 표시되면 **확인**을 클릭하여 **origin/main**과의 커밋 푸시 및 풀을 진행합니다.

#### <a name="task-2-review-commits"></a>작업 2: 커밋 검토

이 작업에서는 Azure DevOps 포털을 사용하여 커밋을 검토합니다.

1. Azure DevOps 인터페이스가 표시된 웹 브라우저 창으로 전환합니다.
1. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos** 섹션에서**커밋**을 선택합니다.
1. 목록 맨 위에 커밋이 표시되는지 확인합니다.

    ![ADO 리포지토리 커밋](images/ado-commit.png)

#### <a name="task-3-stage-changes"></a>작업 3: 변경 내용 스테이징

이 작업에서는 Visual Studio Code를 사용하여 변경 내용을 스테이징하는 방법을 살펴봅니다. 변경 내용을 스테이징하면 커밋에 특정 파일을 선택하여 추가하고 다른 파일의 변경 내용은 제외할 수 있습니다.

1. **Visual Studio Code** 창으로 다시 전환합니다.
1. 첫 번째 주석을 다음으로 변경하고 파일을 저장하여 열려 있는 **Program.cs** 클래스를 업데이트합니다.

```csharp
    //My second change
```

1. Visual Studio Code 창에서 **탐색기** 탭으로 다시 전환한 후 **/eShopOnWeb/src/Web/Constants.cs** 파일로 이동하고 해당 파일을 선택합니다. 그러면 세부 정보 창에 파일 내용이 자동으로 표시됩니다.
1. **Constants.cs** 파일의 첫 번째 줄에 주석을 추가하고 파일을 저장합니다.

    ```csharp
    // My third change
    ```

1. Visual Studio Code 창에서 **소스 제어** 탭으로 전환하여 **Program.cs** 항목 위에 마우스 포인터를 놓고 해당 항목 오른쪽의 더하기 기호를 클릭합니다.

    > **참고**: 이 작업을 수행하면 **Program.cs** 파일의 변경 내용만 스테이징되어 커밋 가능하도록 준비되며 **Constants.cs**는 준비되지 않습니다.

1. **소스 제어** 탭을 선택한 상태로 창 위쪽의 텍스트 상자에 커밋 메시지로 **Added comments**를 입력합니다.

    ![스테이징된 변경 내용](images/staged-changes.png)

1. **소스 제어** 탭 위쪽에서 줄임표 기호를 클릭하고 드롭다운 메뉴에서 **커밋**을 클릭한 후 계단식 메뉴에서 **스테이징된 항목 커밋**을 클릭합니다.
1. Visual Studio Code 창 왼쪽 아래에서 **변경 내용 동기화** 단추를 클릭하여 커밋된 변경 내용을 서버와 동기화합니다. 계속 진행할지를 묻는 메시지가 표시되면 **확인**을 클릭하여 **origin/main**과의 커밋 푸시 및 풀을 진행합니다.

    > **참고**: 스테이징된 변경 내용만 커밋되었으므로 나머지 변경 내용은 아직 동기화 보류 중인 상태입니다.

### <a name="exercise-3-review-history"></a>연습 3: 기록 검토

이 연습에서는 Azure DevOps 포털을 사용하여 커밋 기록을 검토합니다.

Git에서는 각 커밋에 저장된 상위 참조 정보를 사용하여 개발 과정의 전체 기록을 관리합니다. 터미널이나 다양하게 제공되는 Visual Studio Code 확장 중 하나를 사용하면 이 커밋 기록을 손쉽게 검토하여 파일을 변경한 시기를 파악하고 코드 버전 간의 차이점을 확인할 수 있습니다. Azure DevOps 포털을 사용하여 변경 내용을 검토할 수도 있습니다.

Git에서는 끌어오기 요청을 통해 **분기 및 병합** 기능을 사용합니다. 따라서 개발 과정의 커밋 기록이 항상 시간순으로 제공되는 것은 아닙니다. 그러므로 기록을 사용해 버전을 비교할 때는 두 시점 간의 파일 변경 내용이 아니라 두 커밋 간의 파일 변경 내용을 확인해야 합니다. 가령 2주 전에 feature 분기에서 변경 내용이 커밋되었는데 이 분기가 어제 master 분기에 병합되어 master 분기의 파일에서는 해당 변경 내용이 최신 항목일 수도 있습니다.

#### <a name="task-1-compare-files"></a>작업 1: 파일 비교

이 작업에서는 Azure DevOps 포털을 사용하여 커밋 기록을 살펴봅니다.

1. Visual Studio Code 창에서 **소스 제어** 탭을 연 상태로 파일의 스테이징되지 않은 버전을 나타내는 **Constants.cs**를 선택합니다.

    ![파일 비교](images/file-comparison.png)

    > **참고**: 그러면 비교 보기가 열리므로 적용된 변경 내용을 쉽게 찾을 수 있습니다. 여기서는 주석만 하나 추가되었습니다.

1. **Azure DevOps** 포털의 **커밋** 창이 표시된 웹 브라우저 창으로 전환하여 소스 분기와 병합 항목을 검토합니다. 그러면 소스에 변경 내용이 적용된 시기와 방식을 편리하게 시각화할 수 있습니다.
1. 아래쪽의 **내 커밋** 항목(이전에 푸시한 항목)으로 스크롤한 다음 해당 항목 위에 마우스 포인터를 놓으면 오른쪽에 줄임표 기호가 표시됩니다.
1. 줄임표를 클릭하고 드롭다운 메뉴에서 **파일 찾아보기**를 선택한 후에 결과를 검토합니다.

    ![커밋 찾아보기](images/commit-browse.png)

    > **참고**: 이 보기에는 커밋에 해당하는 소스 상태가 표시됩니다. 따라서 각 소스 파일을 검토하고 다운로드할 수 있습니다.

### <a name="exercise-4-work-with-branches"></a>연습 4: 분기 사용

이 연습에서는 Visual Studio Code 및 Azure DevOps 포털을 사용하여 분기 관리 시나리오를 단계별로 진행합니다.

Azure DevOps 포털 내 **Azure Repos**의 **분기** 보기에서 Azure DevOps Git 리포지토리의 분기를 관리할 수 있습니다. 이 보기를 사용자 지정하여 가장 중요한 분기를 추적할 수도 있습니다. 그러면 팀에서 적용한 변경 내용을 항상 파악할 수 있습니다.

변경 내용을 분기에 커밋해도 다른 분기에는 아무런 영향이 없습니다. 그러므로 주 프로젝트에 변경 내용을 병합하지 않고도 다른 사용자와 분기를 공유할 수 있습니다. 새 분기를 만들어 특정 기능의 변경 내용이나 버그 수정을 master 분기 및 기타 작업에서 격리할 수도 있습니다. 분기는 구조가 단순하므로 빠르고 쉽게 분기 간을 전환할 수 있습니다. 분기 사용 시 Git에서는 소스의 복사본을 여러 개 만들지 않으며, 분기 사용을 시작할 때 커밋에 저장된 기록 정보를 사용하여 해당 분기에 파일을 다시 만듭니다. Git 워크플로에서는 기능 및 버그 수정 관리용 분기를 만들어서 사용합니다. 코드 공유, 끌어오기 요청을 통해 코드 검토 등 Git 워크플로에서 수행하는 나머지 작업에서는 모두 분기를 사용합니다. 분기별로 작업을 격리하는 경우 현재 분기만 변경하면 작업 중인 내용을 쉽게 변경할 수 있습니다.

#### <a name="task-1-create-a-new-branch-in-your-local-repository"></a>작업 1: 로컬 리포지토리에 새 분기 만들기

이 작업에서는 Visual Studio Code를 사용하여 분기를 만듭니다.

1. 랩 컴퓨터에서 실행 중인 **Visual Studio Code**로 전환합니다.
1. **소스 제어** 탭을 선택한 상태로 Visual Studio Code 창 왼쪽 아래에서 **main**을 클릭합니다.
1. 팝업 창에서 **+ 새 분기 만들기...** 를 선택합니다.

    ![분기 만들기](images/create-branch.png)

1. **분기 이름** 텍스트 상자에 **dev**를 입력하여 새 분기를 지정하고 **Enter** 키를 누릅니다.
1. **'dev' 분기를 만들 참조 선택** 텍스트 상자에서 참조 분기로 **main**을 선택합니다.

    > **참고**: 그러면 **dev** 분기로 자동 전환됩니다.

#### <a name="task-2-delete-a-branch"></a>작업 2: 분기 삭제

이 작업에서는 이전 작업에서 만든 분기를 Visual Studio Code를 통해 사용합니다.

Git에서는 작업 중인 분기를 추적하며 분기 체크 아웃 시 파일이 해당 분기의 최신 커밋과 일치하는지를 확인합니다. 분기를 활용하면 같은 로컬 Git 리포지토리에 있는 소스 코드의 여러 버전을 동시에 사용할 수 있습니다. Visual Studio Code를 사용하여 분기를 게시, 체크 아웃 및 삭제할 수 있습니다.

1. **Visual Studio Code** 창에서 **소스 제어** 탭을 선택한 상태로 Visual Studio Code 창 왼쪽 아래에 있는 **변경 내용 게시** 아이콘을 클릭합니다. 이 아이콘은 새로 만든 분기를 나타내는 **dev** 레이블 바로 오른쪽에 있습니다.
1. **Azure DevOps** 포털의 **커밋** 창이 표시된 웹 브라우저 창으로 전환하여 **분기**를 선택합니다.
1. **분기** 창의 **내 항목** 탭에서 분기 목록에 **dev**가 포함되어 있는지 확인합니다.
1. **dev** 분기 항목 위에 마우스 포인터를 올리면 오른쪽에 줄임표 기호가 표시됩니다.
1. 줄임표를 클릭하고 팝업 메뉴에서 분기 삭제를 선택한 다음 **분기 삭제**를 확인하라는 메시지가 표시되면 **삭제**를 클릭합니다.

    ![분기 삭제](images/delete-branch.png)

1. **Visual Studio Code** 창으로 다시 전환하여 **소스 제어** 탭을 선택한 상태로 Visual Studio Code 창 왼쪽 아래에서 **dev** 항목을 클릭합니다. 그러면 Visual Studio Code 창 위쪽에 기존 분기가 표시됩니다.
1. **dev** 분기 2개가 목록에 표시됨을 확인합니다.

    > **참고**: 로컬(**dev**) 분기가 목록에 표시되는 이유는, 원격 리포지토리에서 분기를 삭제해도 로컬 분기에는 아무런 영향이 없기 때문입니다. 서버(**origin/dev**) 분기는 정리되지 않았으므로 목록에 표시됩니다.

1. 분기 목록에서 **main** 분기를 선택하여 체크 아웃합니다.
1. **Ctrl+Shift+P**를 눌러 **명령 팔레트**를 엽니다.
1. **명령 팔레트** 프롬프트에서 **Git: Delete** 입력을 시작하여 **Git: Delete Branch**가 표시되면 선택합니다.
1. 삭제할 분기 목록에서 **dev** 항목을 선택합니다.
1. Visual Studio Code 창 왼쪽 아래에서 **main** 항목을 다시 클릭합니다. 그러면 Visual Studio Code 창 위쪽에 기존 분기가 표시됩니다.
1. 로컬 **dev** 분기는 목록에 더 이상 표시되지 않으며 원격 **origin/dev** 분기는 계속 표시됨을 확인합니다.
1. **Ctrl+Shift+P**를 눌러 **명령 팔레트**를 엽니다.
1. **명령 팔레트** 프롬프트에서 **Git: Fetch** 입력을 시작하고 **Git: Fetch(Prune)** 가 표시되면 선택합니다.

    > **참고**: 이 명령을 실행하면 로컬 스냅숏의 원래 분기가 업데이트ehlau 스냅숏에 더 이상 없는 분기는 삭제됩니다.

    > **참고**: Visual Studio Code 창 오른쪽 아래의 **출력** 창을 선택하면 이러한 작업의 정확한 내용을 확인할 수 있습니다. 출력 콘솔에 Git 로그가 표시되지 않으면 소스로 **Git**를 선택합니다.

1. Visual Studio Code 창 왼쪽 아래에서 **main** 항목을 다시 클릭합니다.
1. 분기 목록에 **origin/dev** 분기가 더 이상 표시되지 않음을 확인합니다.

#### <a name="task-3-restore-a-branch"></a>작업 3: 분기 복원

이 작업에서는 Azure DevOps 포털을 사용하여 이전 작업에서 삭제한 분기를 복원합니다.

1. Azure DevOps 포털의 **분기** 창 **내 항목** 탭이 표시된 웹 브라우저로 전환합니다.
1. **분기** 창의 **내 항목** 탭에서 **모두** 탭을 클릭합니다.
1. **분기** 창의 **모두** 탭에 있는 **분기 이름 검색** 텍스트 상자에 **dev**를 입력합니다.
1. 새로 삭제한 분기를 나타내는 항목이 포함된 **삭제된 분기** 섹션을 검토합니다.
1. **삭제된 분기** 섹션에서 **dev** 분기 항목 위에 마우스 포인터를 올리면 오른쪽에 줄임표 기호가 표시됩니다.
1. 팝업 메뉴에서 줄임표를 클릭하고 **분기 복원**을 선택합니다.

    ![분기 복원](images/restore-branch.png)

    > **참고**: 삭제한 분기의 정확한 이름을 알고 있다면 이 기능을 사용하여 삭제한 분기를 복원할 수 있습니다.

#### <a name="task-4-branch-policies"></a>작업 4: 분기 정책


이 작업에서는 Azure DevOps 포털을 사용하여 기본 분기에 정책을 추가하며, 정의된 정책을 준수하는 끌어오기 요청을 사용하는 변경 내용만 허용합니다. 분기의 변경 내용을 병합하기 전에 해당 변경 내용을 검토하려 합니다.

간단한 작업을 위해 VS Code에서 로컬 클론을 사용하는 대신, 웹 브라우저 리포지토리 편집기에서 직접 작업(원본에서 직접 작업)합니다. 이는 실제 시나리오에 권장됩니다.

1. Azure DevOps 포털의 **분기** 창 **내 항목** 탭이 표시된 웹 브라우저로 전환합니다.
1. **분기** 창의 **내 항목** 탭에서 **main** 분기 항목 위에 마우스 포인터를 올리면 오른쪽에 줄임표 기호가 표시됩니다.
1. 줄임표를 클릭하고 팝업 메뉴에서 **분기 정책**을 선택합니다.

    ![분기 정책](images/branch-policies.png)

1. 리포지토리 설정의 **main** 탭에서 **최소 검토자 수 필요** 옵션을 사용하도록 설정합니다. 검토자 **1**명을 추가하고 **요청자가 자신의 변경 내용을 승인할 수 있음**(현재 수강생 본인이 랩 프로젝트의 유일한 사용자이므로) 확인란을 선택합니다.
1. 1. 리포지토리 설정의 **main** 탭에서 **연결된 작업 항목 확인** 옵션을 사용하도록 설정하고 **필수** 옵션으로 그대로 둡니다.

    ![정책 설정](images/policy-settings.png)

#### <a name="task-5-testing-branch-policy"></a>작업 5: 분기 정책 테스트

이 작업에서는 Azure DevOps 포털을 사용하여 정책을 테스트하고 첫 번째 끌어오기 요청을 만듭니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos > 파일**에서 **main** 분기가 선택되어 있는지 확인합니다(표시된 콘텐츠 위의 드롭다운).
1. 정책이 작동하는지 확인하려면 변경 내용을 적용하고 **main** 분기에서 커밋한 다음, **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하고 해당 파일을 선택합니다. 그러면 세부 정보 창에 파일 내용이 자동으로 표시됩니다.
1. 첫 번째 줄에 다음 주석을 추가합니다.

    ```csharp
    // Testing main branch policy
    ```

1. **커밋 > 커밋**을 클릭합니다. 경고가 표시됩니다. 기본 분기를 변경하는 건 끌어오기 요청을 사용하는 경우에만 가능합니다.

    ![정책 거부 커밋](images/policy-denied.png)

1. **취소**를 클릭하여 커밋을 건너뜁니다.

#### <a name="task-6-working-with-pull-requests"></a>작업 6: 끌어오기 요청 작업

이 작업에서는 Azure DevOps 포털을 사용하여 끌어오기 요청을 만듭니다. 끌어오기 요청은 **dev** 분기를 사용하여 변경 내용을 보호된 **main** 분기에 병합합니다. Azure DevOps 작업 항목은 코드 작업으로 보류 중인 작업을 추적할 수 있도록 변경 내용에 연결됩니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Boards** 섹션에서 **작업 항목**을 선택합니다.
1. **+ 새 작업 항목 > 제품 백로그 항목**을 클릭합니다. 제목 필드에 **내 첫 번째 PR 테스트**라고 작성한 후 **저장**을 클릭합니다.
1. 이제 Azure DevOps 포털의 세로 탐색 창으로 돌아간 다음, **Repos > 파일**에서 **dev** 분기가 선택되어 있는지 확인합니다.
1. **/eShopOnWeb/src/Web/Program.cs** 파일로 이동하여 첫 번째 줄에서 다음을 변경합니다.

    ```csharp
    // Testing my first PR
    ```
1. **커밋 > 커밋**을 클릭합니다(기본 커밋 메시지는 그대로 둠). 이번에는 커밋이 작동하며 **dev** 분기에는 정책이 없습니다.
1. 끌어오기 요청을 만들도록 제안하는 메시지가 팝업 창에 표시됩니다. 이제 **dev** 분기가 **main**과 비교하여 변경 내용에서 앞서 있기 때문입니다. **끌어오기 요청 만들기**를 클릭합니다.

    ![끌어오기 요청 만들기](images/create-pr.png)

1. **새 끌어오기 요청** 탭에서 기본값은 그대로 두고 **만들기**를 클릭합니다.
1. 대상 **main** 분기에 적용된 정책에 따라, 끌어오기 요청에는 몇 가지 실패/보류 중인 요구 사항이 표시됩니다.
    - 제안된 변경 내용에 연결된 작업 항목이 있어야 합니다.
    - 1명 이상의 사용자가 변경 내용을 검토하고 승인해야 합니다.

1. 오른쪽 옵션에서 **작업 항목** 옆의 **+** 단추를 클릭합니다. 이전에 만든 작업 항목을 클릭하여 끌어오기 요청에 연결합니다. 요구 사항의 변경 상태 중 하나가 표시됩니다.

    ![작업 항목 연결](images/link-wit.png)

1. 그 다음, **파일** 탭을 열어 제안된 변경 내용을 검토합니다. 추가 끌어오기 요청 완료에서는 파일을 하나씩 검토하고(검토된 것으로 표시됨), 명확하지 않은 줄에 대한 주석을 열어볼 수 있습니다(줄 번호 위에 마우스를 올리면 주석을 게시할 수 있는 옵션이 제공됨).
1. **개요** 탭으로 돌아간 후 오른쪽 상단에서 **승인**을 클릭합니다. 모든 요구 사항이 녹색으로 변경됩니다. 이제 **완료**를 클릭할 수 있습니다.
1. **끌어오기 요청 완료** 탭에서는 병합을 완료하기 전에 여러 옵션이 제공됩니다.
    - **병합 형식**: 4가지 병합 형식이 제공되며, [여기에서](https://learn.microsoft.com/azure/devops/repos/git/complete-pull-requests?view=azure-devops&tabs=browser#complete-a-pull-request)이를 검토하거나 제공된 애니메이션을 확인할 수 있습니다. **병합(빨리 감기 안 함)** 을 선택합니다.
    - **완료 후 옵션**:
        - **연결된 작업 항목 완료...** 를 선택합니다. 이렇게 하면 연결된 PBI가 **완료** 상태로 이동합니다.
    
2. **병합 완료**를 클릭합니다.
        
#### <a name="task-7-applying-tags"></a>작업 7: 태그 적용

제품 팀이 사이트의 현재 버전을 v1.1.0-beta로 릴리스하기로 결정했습니다.

1. Azure DevOps 포털의 세로 탐색 창에 있는 **Repos** 섹션에서 **태그**를 선택합니다.
1. **태그** 창에서 **새 태그**를 클릭합니다.
1. **태그 만들기**패널의 **이름** 텍스트 상자에 **v1.1.0-beta**를 입력하고 **기준** 드롭다운 목록에서는 **main** 항목을 그대로 선택해 둡니다. **설명** 텍스트 상자에는 **베타 릴리스 v1.1.0**을 입력하고 **만들기**를 클릭합니다.

    > **참고**: 이제 이 릴리스에서 리포지토리에 태그를 지정했습니다(최신 커밋이 태그에 연결됨). 다양한 상황에서 커밋에 태그를 지정할 수 있습니다. Azure DevOps에서는 태그를 유동적으로 편집하고 삭제할 수 있으며 태그 권한도 관리할 수 있습니다.

## <a name="review"></a>검토

이 랩에서는 Azure DevOps 포털을 사용하여 분기와 리포지토리를 관리했습니다.
